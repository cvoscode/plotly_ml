{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Plotly ML","text":"<p>Interactive Machine Learning Visualizations with Plotly</p>"},{"location":"#overview","title":"Overview","text":"<p>This project creates plots for machine learning similar to Yellowbrick, but using Plotly for interactive visualizations. It provides a scikit-learn style interface that is also AutoGluon ready.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Interactive visualizations using Plotly</li> <li>Scikit-learn style interface</li> <li>AutoGluon compatibility</li> <li>Efficient data handling with Polars and Pandas</li> <li>Enhanced logging with Loguru</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>We use <code>uv</code> for dependency management. To install the required dependencies:</p> <pre><code>uv sync\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Here's a simple example using the regression evaluation plot:</p> <pre><code>import plotly_ml as pml\nimport polars as pl\n\n# Prepare your data\ndata = pl.DataFrame({\n    'y_true': y_true,\n    'y_pred': y_pred,\n    'set': ['train'] * len(y_train) + ['test'] * len(y_test)\n})\n\n# Create the evaluation plot\nfig = pml.regression_evaluation_plot(data)\nfig.show()\n</code></pre>"},{"location":"#components","title":"Components","text":"<p>The library includes several components for different visualization needs:</p> <ul> <li>Regression Analysis: Comprehensive evaluation plots for regression models</li> <li>Univariant Analysis: Distribution analysis with raincloud plots</li> <li>Metrics: Common regression metrics (R\u00b2, RMSE, MAE, etc.)</li> <li>Colors: Utilities for color handling and conversion</li> </ul>"},{"location":"api/colors/","title":"Colors","text":"<p>This module provides utilities for color handling and conversion between different formats (RGB, RGBA, Hex).</p>"},{"location":"api/colors/#colors","title":"<code>colors</code>","text":""},{"location":"api/colors/#colors.hex_to_rgb","title":"<code>hex_to_rgb(hex_color)</code>","text":"<p>Convert a hex color string to RGB tuple.</p> <p>Parameters:</p> Name Type Description Default <code>hex_color</code> <code>str</code> <p>Hex color string (e.g., '#FF0000' or '#F00').</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>RGB color tuple (r, g, b) with values between 0 and 255.</p> Source code in <code>colors.py</code> <pre><code>def hex_to_rgb(hex_color):\n    \"\"\"Convert a hex color string to RGB tuple.\n\n    Args:\n        hex_color (str): Hex color string (e.g., '#FF0000' or '#F00').\n\n    Returns:\n        tuple: RGB color tuple (r, g, b) with values between 0 and 255.\n    \"\"\"\n    h = hex_color.lstrip('#')\n    if len(h) == 3: h = ''.join([c*2 for c in h])\n    r = int(h[0:2], 16); g = int(h[2:4], 16); b = int(h[4:6], 16)\n    return r, g, b\n</code></pre>"},{"location":"api/colors/#colors.rgb_string_to_tuple","title":"<code>rgb_string_to_tuple(s)</code>","text":"<p>Convert an RGB string to a tuple of integers.</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>RGB string (e.g., 'rgb(255,0,0)' or 'rgb(1.0,0,0)').</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <p>RGB color tuple (r, g, b) with values between 0 and 255.</p> Source code in <code>colors.py</code> <pre><code>def rgb_string_to_tuple(s):\n    \"\"\"Convert an RGB string to a tuple of integers.\n\n    Args:\n        s (str): RGB string (e.g., 'rgb(255,0,0)' or 'rgb(1.0,0,0)').\n\n    Returns:\n        tuple: RGB color tuple (r, g, b) with values between 0 and 255.\n    \"\"\"\n    nums = list(map(float, re.findall(r\"[\\d.]+\", s)))\n    return tuple(_int_if_float(n) for n in nums[:3])\n</code></pre>"},{"location":"api/colors/#colors.to_rgba","title":"<code>to_rgba(color, alpha=0.3)</code>","text":"<p>Convert various color formats to an RGBA string.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <p>Color specification in one of these formats: - RGB tuple (0-255 or 0-1) - RGBA string - RGB string - Hex color string</p> required <code>alpha</code> <code>float</code> <p>Alpha value between 0 and 1. Defaults to 0.3.</p> <code>0.3</code> <p>Returns:</p> Name Type Description <code>str</code> <p>RGBA color string in format 'rgba(r,g,b,a)'.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the color format is not supported.</p> Source code in <code>colors.py</code> <pre><code>def to_rgba(color, alpha=0.3):\n    \"\"\"Convert various color formats to an RGBA string.\n\n    Args:\n        color: Color specification in one of these formats:\n            - RGB tuple (0-255 or 0-1)\n            - RGBA string\n            - RGB string\n            - Hex color string\n        alpha (float, optional): Alpha value between 0 and 1. Defaults to 0.3.\n\n    Returns:\n        str: RGBA color string in format 'rgba(r,g,b,a)'.\n\n    Raises:\n        ValueError: If the color format is not supported.\n    \"\"\"\n    if isinstance(color, (tuple, list)):\n        r, g, b = color[:3]\n        # handle 0..1 floats\n        if max(r,g,b) &lt;= 1:\n            r, g, b = [_int_if_float(x) for x in (r,g,b)]\n        return f\"rgba({int(r)},{int(g)},{int(b)},{float(alpha)})\"\n    c = str(color).strip()\n    if c.startswith(\"rgba\"):\n        parts = re.findall(r\"[\\d.]+\", c)#\n        r,g,b,_ = parts[:4]\n        return f\"rgba({int(float(r))},{int(float(g))},{int(float(b))},{float(alpha)})\"\n    if c.startswith(\"rgb\"):\n        r,g,b = rgb_string_to_tuple(c)\n        return f\"rgba({r},{g},{b},{float(alpha)})\"\n    if c.startswith(\"#\"):\n        r,g,b = hex_to_rgb(c)\n        return f\"rgba({r},{g},{b},{float(alpha)})\"\n    raise ValueError(f\"Unsupported color format: {color}\")\n</code></pre>"},{"location":"api/metrics/","title":"Metrics","text":"<p>This module provides common metrics for evaluating regression models.</p>"},{"location":"api/metrics/#metrics","title":"<code>metrics</code>","text":""},{"location":"api/metrics/#metrics.bias","title":"<code>bias(y_true, y_pred)</code>","text":"<p>Calculate the bias (mean error) between predictions and ground truth.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>Series</code> <p>Ground truth (correct) target values.</p> required <code>y_pred</code> <code>Series</code> <p>Estimated target values.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean prediction error (bias).</p> Source code in <code>metrics.py</code> <pre><code>def bias(y_true: pl.Series, y_pred: pl.Series) -&gt; float:\n    \"\"\"Calculate the bias (mean error) between predictions and ground truth.\n\n    Args:\n        y_true (pl.Series): Ground truth (correct) target values.\n        y_pred (pl.Series): Estimated target values.\n\n    Returns:\n        float: Mean prediction error (bias).\n    \"\"\"\n    return (y_true - y_pred).mean()\n</code></pre>"},{"location":"api/metrics/#metrics.count","title":"<code>count(y_true, y_pred)</code>","text":"<p>Count the number of samples in the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>Series</code> <p>Ground truth (correct) target values.</p> required <code>y_pred</code> <code>Series</code> <p>Estimated target values.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>Number of samples.</p> Source code in <code>metrics.py</code> <pre><code>def count(y_true: pl.Series, y_pred: pl.Series) -&gt; int:\n    \"\"\"Count the number of samples in the dataset.\n\n    Args:\n        y_true (pl.Series): Ground truth (correct) target values.\n        y_pred (pl.Series): Estimated target values.\n\n    Returns:\n        int: Number of samples.\n    \"\"\"\n    return len(y_true)\n</code></pre>"},{"location":"api/metrics/#metrics.mae","title":"<code>mae(y_true, y_pred)</code>","text":"<p>Calculate Mean Absolute Error between predictions and ground truth.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>Series</code> <p>Ground truth (correct) target values.</p> required <code>y_pred</code> <code>Series</code> <p>Estimated target values.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Mean absolute error.</p> Source code in <code>metrics.py</code> <pre><code>def mae(y_true: pl.Series, y_pred: pl.Series) -&gt; float:\n    \"\"\"Calculate Mean Absolute Error between predictions and ground truth.\n\n    Args:\n        y_true (pl.Series): Ground truth (correct) target values.\n        y_pred (pl.Series): Estimated target values.\n\n    Returns:\n        float: Mean absolute error.\n    \"\"\"\n    return (y_true - y_pred).abs().mean()\n</code></pre>"},{"location":"api/metrics/#metrics.r2_score","title":"<code>r2_score(y_true, y_pred)</code>","text":"<p>Calculate the R\u00b2 (coefficient of determination) regression score.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>Series</code> <p>Ground truth (correct) target values.</p> required <code>y_pred</code> <code>Series</code> <p>Estimated target values.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>R\u00b2 score. Best possible score is 1.0, and it can be negative.</p> Source code in <code>metrics.py</code> <pre><code>def r2_score(y_true: pl.Series, y_pred: pl.Series) -&gt; float:\n    \"\"\"Calculate the R\u00b2 (coefficient of determination) regression score.\n\n    Args:\n        y_true (pl.Series): Ground truth (correct) target values.\n        y_pred (pl.Series): Estimated target values.\n\n    Returns:\n        float: R\u00b2 score. Best possible score is 1.0, and it can be negative.\n    \"\"\"\n    ss_res = ((y_true - y_pred) ** 2).sum()\n    ss_tot = ((y_true - y_true.mean()) ** 2).sum()\n    return 1 - (ss_res / ss_tot)\n</code></pre>"},{"location":"api/metrics/#metrics.rmse","title":"<code>rmse(y_true, y_pred)</code>","text":"<p>Calculate Root Mean Square Error between predictions and ground truth.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>Series</code> <p>Ground truth (correct) target values.</p> required <code>y_pred</code> <code>Series</code> <p>Estimated target values.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Root mean square error.</p> Source code in <code>metrics.py</code> <pre><code>def rmse(y_true: pl.Series, y_pred: pl.Series) -&gt; float:\n    \"\"\"Calculate Root Mean Square Error between predictions and ground truth.\n\n    Args:\n        y_true (pl.Series): Ground truth (correct) target values.\n        y_pred (pl.Series): Estimated target values.\n\n    Returns:\n        float: Root mean square error.\n    \"\"\"\n    return ((y_true - y_pred) ** 2).mean().sqrt()\n</code></pre>"},{"location":"api/metrics/#metrics.var","title":"<code>var(y_true, y_pred)</code>","text":"<p>Calculate the variance of the prediction errors.</p> <p>Parameters:</p> Name Type Description Default <code>y_true</code> <code>Series</code> <p>Ground truth (correct) target values.</p> required <code>y_pred</code> <code>Series</code> <p>Estimated target values.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Variance of prediction errors.</p> Source code in <code>metrics.py</code> <pre><code>def var(y_true: pl.Series, y_pred: pl.Series) -&gt; float:\n    \"\"\"Calculate the variance of the prediction errors.\n\n    Args:\n        y_true (pl.Series): Ground truth (correct) target values.\n        y_pred (pl.Series): Estimated target values.\n\n    Returns:\n        float: Variance of prediction errors.\n    \"\"\"\n    return (y_true - y_pred).var()\n</code></pre>"},{"location":"api/regression/","title":"Regression","text":"<p>This module provides visualization tools for regression model evaluation.</p>"},{"location":"api/regression/#regression","title":"<code>regression</code>","text":""},{"location":"api/regression/#regression.regression_evaluation_plot","title":"<code>regression_evaluation_plot(data=None, y=None, split_column='set', template='plotly_white', colors=None)</code>","text":"<p>Create a comprehensive regression model evaluation plot with multiple subplots.</p> <p>This function creates an interactive visualization that includes: - Prediction error scatter plot with ideal line - Marginal distributions using violin plots - Residuals plot - Summary metrics table (R\u00b2, MAE, RMSE, Bias, Variance, Sample size)</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[DataFrame, DataFrame]</code> <p>DataFrame containing true values, predictions and split information. Must contain columns 'y_true' and 'y_pred'.</p> <code>None</code> <code>y</code> <code>str</code> <p>Name of the target variable. Not currently used. Defaults to None.</p> <code>None</code> <code>split_column</code> <code>str</code> <p>Name of the column containing split information (e.g., 'train'/'test').  Defaults to 'set'.</p> <code>'set'</code> <code>template</code> <code>str</code> <p>Plotly template to use. Defaults to 'plotly_white'.</p> <code>'plotly_white'</code> <code>colors</code> <code>list</code> <p>List of colors to use for different splits.  If None, uses Plotly's default D3 qualitative color scale.</p> <code>None</code> <p>Returns:</p> Type Description <p>go.Figure: A plotly figure object containing the regression evaluation plots.</p> Source code in <code>regression.py</code> <pre><code>def regression_evaluation_plot(data:Union[pl.DataFrame,pd.DataFrame]=None, y:str=None, split_column:str='set', template='plotly_white', colors:list=None):\n    \"\"\"Create a comprehensive regression model evaluation plot with multiple subplots.\n\n    This function creates an interactive visualization that includes:\n    - Prediction error scatter plot with ideal line\n    - Marginal distributions using violin plots\n    - Residuals plot\n    - Summary metrics table (R\u00b2, MAE, RMSE, Bias, Variance, Sample size)\n\n    Args:\n        data (Union[pl.DataFrame,pd.DataFrame]): DataFrame containing true values, predictions and split information.\n            Must contain columns 'y_true' and 'y_pred'.\n        y (str, optional): Name of the target variable. Not currently used. Defaults to None.\n        split_column (str, optional): Name of the column containing split information (e.g., 'train'/'test'). \n            Defaults to 'set'.\n        template (str, optional): Plotly template to use. Defaults to 'plotly_white'.\n        colors (list, optional): List of colors to use for different splits. \n            If None, uses Plotly's default D3 qualitative color scale.\n\n    Returns:\n        go.Figure: A plotly figure object containing the regression evaluation plots.\n    \"\"\"\n    if isinstance(data, pd.DataFrame):\n        data = pl.from_pandas(data)\n\n    specs = [\n        [{\"type\": \"xy\"}, {\"type\": \"xy\"}],   # row 1: left = xy, right = domain (table goes here)\n        [{\"type\": \"xy\"}, {\"type\": \"xy\"}],       # row 2\n        [{\"type\": \"xy\"}, {\"type\": \"xy\"}],       # spacer row (still xy but empty)\n        [{\"type\": \"xy\"}, {\"type\": \"xy\"}], \n        [{\"type\": \"xy\"}, {\"type\": \"xy\"}], \n        [{\"type\": \"domain\"}, {\"type\": \"xy\"}],      # bottom row\n    ]\n\n    # Build a 4-row layout where row 3 is a spacer to control the gap between rows 2 and 4\n    fig = sp.make_subplots(\n        rows=6,\n        cols=2,\n        column_widths=[0.75, 0.25],\n        row_heights=[0.1, 0.4, 0.1, 0.2, 0.1, 0.1],\n        shared_xaxes=True,\n        shared_yaxes='rows',\n        vertical_spacing=0,\n        horizontal_spacing=0,\n        specs=specs,\n        subplot_titles=(\"Prediction Error\", None, None, None, None, None, \"Residuals\", None)\n    )\n\n    # Add reference lines\n    min_val = min(data['y_true'].min(), data['y_pred'].min())\n    max_val = max(data['y_true'].max(), data['y_pred'].max())\n    fig.add_trace(go.Scattergl(\n        x=[min_val, max_val],\n        y=[min_val, max_val],\n        mode='lines',\n        name='Ideal Line',\n        line=dict(color='black', dash='dash'),\n        showlegend=False,\n    ), row=2, col=1)\n\n    fig.add_trace(go.Scattergl(\n        x=[min_val, max_val],\n        y=[0, 0],\n        mode='lines',\n        name='Zero Error Line',\n        line=dict(color='black', dash='dash'),\n        showlegend=False,\n    ), row=4, col=1)\n\n    colors = px.colors.qualitative.D3 if not colors else colors\n\n    # Prepare containers for metrics\n    split_names = []\n    r2_list = []\n    mae_list = []\n    rmse_list = []\n    bias_list = []\n    var_resid_list = []\n    n_list = []\n\n    # --- Add Traces to the Figure and collect metrics ---\n    for i, split in enumerate(data.partition_by(split_column)):\n        split_name = split[split_column].first()\n        y_true = split['y_true']\n        y_pred = split['y_pred']\n\n\n        residuals = y_true - y_pred\n\n        # Compute metrics for this split\n        try:\n            r2 = r2_score(y_true, y_pred)\n        except Exception:\n            r2 = np.nan\n        mae = mae(y_true, y_pred)\n        rmse = rmse(y_true, y_pred)\n        bias = bias(y_true, y_pred)\n        var_resid = var(y_true, y_pred)\n        n = count(y_true, y_pred)\n\n        # Store metrics (keep numeric values for later formatting)\n        split_names.append(str(split_name))\n        r2_list.append(r2)\n        mae_list.append(mae)\n        rmse_list.append(rmse)\n        bias_list.append(bias)\n        var_resid_list.append(var_resid)\n        n_list.append(n)\n\n        line_color = colors[i % len(colors)]\n        fill_color = to_rgba(line_color, alpha=0.25)\n        marker_color = to_rgba(line_color, alpha=0.7)\n\n        # 1. Prediction Error Scatter Plot (middle-left subplot)\n        fig.add_trace(go.Scattergl(\n            x=y_true,\n            y=y_pred,\n            mode='markers',\n            name=f'{split_name}',\n            marker=dict(size=8, opacity=0.7, color=marker_color),\n            legendgroup=f'{split_name}',\n\n        ), row=2, col=1)\n\n\n        # 2. Residuals Scatter Plot (bottom-left subplot)\n        fig.add_trace(go.Scattergl(\n            x=y_true,\n            y=residuals,\n            mode='markers',\n            name=f'Residuals',\n            marker=dict(size=8, opacity=0.7, color=marker_color),\n            legendgroup=f'{split_name}',\n            showlegend=False,\n        ), row=4, col=1)\n\n        # --- Add Marginal Violin Plots ---\n        fig.add_trace(go.Violin(\n            x=y_true,\n            orientation='h',\n            y=[0] * len(y_true),\n            name=f'{split_name}',\n            side='positive',\n            box_visible=True,\n            meanline_visible=True,\n            fillcolor=fill_color,\n            opacity=0.6,\n            line_color=line_color,\n            legendgroup=f'{split_name}',\n            showlegend=False,\n            scalegroup='same',\n            scalemode='width',\n            width=0.6,\n            offsetgroup='overlay',\n            alignmentgroup='overlay',\n            points=False\n        ), row=1, col=1)\n\n        fig.add_trace(go.Violin(\n            y=y_pred,\n            name=f'{split_name}',\n            orientation='v',\n            x=[0]*len(y_pred),\n            side='positive',\n            box_visible=True,\n            meanline_visible=True,\n            fillcolor=fill_color,\n            opacity=0.6,\n            line_color=line_color,\n            legendgroup=f'{split_name}',\n            showlegend=False,\n            scalegroup='same',\n            scalemode='width',\n            width=0.6,\n            offsetgroup='overlay',\n            alignmentgroup='overlay',\n            points=False\n        ), row=2, col=2)\n\n        fig.add_trace(go.Violin(\n            y=residuals,\n            name=f'{split_name}',\n            x=[0]*len(y_pred),\n            side='positive',\n            box_visible=True,\n            meanline_visible=True,\n            fillcolor=fill_color,\n            opacity=0.6,\n            line_color=line_color,\n            legendgroup=f'{split_name}',\n            showlegend=False,\n            scalegroup='same',\n            scalemode='width',\n            width=0.6,\n            offsetgroup='overlay',\n            alignmentgroup='overlay',\n            points=False\n        ), row=4, col=2)\n\n    # --- Add compact metrics table (top-right) ---\n    # Format numeric columns to short strings for compact display\n    fmt = lambda arr, fmt_str: [\"{0}\".format(\"{:.3f}\".format(x) if isinstance(x, (int, float, np.floating, np.integer)) and not np.isnan(x) else \"nan\") for x in arr]\n    header_vals = [\"Split\", \"R2\", \"MAE\", \"RMSE\", \"Bias\", \"VarRes\", \"N\"]\n    cell_vals = [\n        split_names,\n        fmt(r2_list, \"{:.3f}\"),\n        fmt(mae_list, \"{:.3f}\"),\n        fmt(rmse_list, \"{:.3f}\"),\n        fmt(bias_list, \"{:.3f}\"),\n        fmt(var_resid_list, \"{:.3f}\"),\n        [str(x) for x in n_list]\n    ]\n\n    # Add the table into the top-right subplot slot\n    fig.add_trace(go.Table(\n        header=dict(values=header_vals, fill_color='lightgrey', align='left', font=dict(size=9)),\n        cells=dict(values=cell_vals, align='left', font=dict(size=9))\n    ), row=6, col=1)\n\n    # --- Update Layout and Axes ---\n    fig.update_layout(\n        height=900,\n        width=700,\n        title_text=\"Regression Model Analysis\",\n        template=template,\n    )\n\n    # Main plot axes\n    fig.update_yaxes(title_text=\"Predicted Values\", row=2, col=1)\n    fig.update_yaxes(title_text=\"Residuals\", row=4, col=1)\n    fig.update_xaxes(title_text=\"True Values\", row=4, col=1)\n\n    # Hide unnecessary ticks on marginal plots and table subplot\n    fig.update_yaxes(showticklabels=False, row=1, col=1)\n    fig.update_xaxes(showticklabels=False, row=2, col=2)\n    fig.update_xaxes(showticklabels=True, row=3, col=2)\n    fig.update_xaxes(visible=True, showticklabels=True, row=4, col=1)\n    fig.update_xaxes(matches='x4', row=2, col=2)\n    fig.update_layout(violinmode='overlay')\n    return fig\n</code></pre>"},{"location":"api/univariant/","title":"Univariant Analysis","text":"<p>This module provides tools for univariate analysis and distribution visualization.</p>"},{"location":"api/univariant/#univariant","title":"<code>univariant</code>","text":""},{"location":"api/univariant/#univariant.raincloud_plot","title":"<code>raincloud_plot(data, value, group=None, template='plotly_white', colors=None, show_box=True, show_points=True, violin_side='positive', sample_size=5000, title='Raincloud Plot', height=600, width=800)</code>","text":"<p>Create a raincloud plot combining violin plots, box plots, and scatter points.</p> <p>A raincloud plot is a hybrid visualization that combines aspects of violin plots, box plots, and scatter plots to provide a comprehensive view of data distribution.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[DataFrame, DataFrame]</code> <p>Input DataFrame in either Polars or Pandas format.</p> required <code>value</code> <code>Union[str, List[str]]</code> <p>Column name(s) for the variable(s) to plot. Can be a single column name or a list of column names.</p> required <code>group</code> <code>Optional[str]</code> <p>Column name for grouping the data. If None, each value column is treated as a separate group. Defaults to None.</p> <code>None</code> <code>template</code> <code>str</code> <p>Plotly template name. Defaults to \"plotly_white\".</p> <code>'plotly_white'</code> <code>colors</code> <code>Optional[List[str]]</code> <p>List of colors for each group. If None, uses Plotly's D3 qualitative color scale. Defaults to None.</p> <code>None</code> <code>show_box</code> <code>bool</code> <p>Whether to show box plots inside violins. Defaults to True.</p> <code>True</code> <code>show_points</code> <code>bool</code> <p>Whether to show individual data points. Defaults to True.</p> <code>True</code> <code>violin_side</code> <code>str</code> <p>Orientation of violin plots - 'both', 'positive', or 'negative'. Defaults to \"positive\".</p> <code>'positive'</code> <code>sample_size</code> <code>int</code> <p>Maximum number of points to plot if dataset is large. Defaults to 5000.</p> <code>5000</code> <code>title</code> <code>str</code> <p>Plot title. Defaults to \"Raincloud Plot\".</p> <code>'Raincloud Plot'</code> <code>height</code> <code>int</code> <p>Figure height in pixels. Defaults to 600.</p> <code>600</code> <code>width</code> <code>int</code> <p>Figure width in pixels. Defaults to 800.</p> <code>800</code> <p>Returns:</p> Type Description <code>Figure</code> <p>go.Figure: Plotly figure object containing the raincloud plot.</p> Source code in <code>univariant.py</code> <pre><code>def raincloud_plot(\n\tdata: Union[pl.DataFrame, pd.DataFrame],\n\tvalue: Union[str, List[str]],\n\tgroup: Optional[str] = None,\n\ttemplate: str = \"plotly_white\",\n\tcolors: Optional[List[str]] = None,\n\tshow_box: bool = True,\n\tshow_points: bool = True,\n\tviolin_side: str = \"positive\",\n\tsample_size=5_000,\n\ttitle=\"Raincloud Plot\",\n\theight: int = 600,\n\twidth: int = 800,\n) -&gt; go.Figure:\n\t\"\"\"Create a raincloud plot combining violin plots, box plots, and scatter points.\n\n\tA raincloud plot is a hybrid visualization that combines aspects of violin plots,\n\tbox plots, and scatter plots to provide a comprehensive view of data distribution.\n\n\tArgs:\n\t\tdata (Union[pl.DataFrame, pd.DataFrame]): Input DataFrame in either Polars or Pandas format.\n\t\tvalue (Union[str, List[str]]): Column name(s) for the variable(s) to plot.\n\t\t\tCan be a single column name or a list of column names.\n\t\tgroup (Optional[str], optional): Column name for grouping the data.\n\t\t\tIf None, each value column is treated as a separate group. Defaults to None.\n\t\ttemplate (str, optional): Plotly template name. Defaults to \"plotly_white\".\n\t\tcolors (Optional[List[str]], optional): List of colors for each group.\n\t\t\tIf None, uses Plotly's D3 qualitative color scale. Defaults to None.\n\t\tshow_box (bool, optional): Whether to show box plots inside violins. Defaults to True.\n\t\tshow_points (bool, optional): Whether to show individual data points. Defaults to True.\n\t\tviolin_side (str, optional): Orientation of violin plots - 'both', 'positive',\n\t\t\tor 'negative'. Defaults to \"positive\".\n\t\tsample_size (int, optional): Maximum number of points to plot if dataset is large.\n\t\t\tDefaults to 5000.\n\t\ttitle (str, optional): Plot title. Defaults to \"Raincloud Plot\".\n\t\theight (int, optional): Figure height in pixels. Defaults to 600.\n\t\twidth (int, optional): Figure width in pixels. Defaults to 800.\n\n\tReturns:\n\t\tgo.Figure: Plotly figure object containing the raincloud plot.\n\t\"\"\"\n\tif colors is None:\n\t\tcolors = px.colors.qualitative.D3\n\n\t# Convert to Polars for consistency\n\tif isinstance(data, pd.DataFrame):\n\t\tdata = pl.from_pandas(data)\n\n\t# Support multiple columns for value\n\tif isinstance(value, str):\n\t\tvalue_cols = [value]\n\telse:\n\t\tvalue_cols = value\n\tif data.height&gt;sample_size:\n\t\tdata=data.sample(sample_size)\n\tfig = go.Figure()\n\tprint(f\"Value columns: {value_cols}\")\n\tif group is None:\n\t\t# Plot each column as a separate group\n\t\tprint(\"No group specified, plotting each value column separately.\")\n\t\tfor i, col in enumerate(value_cols):\n\t\t\tvals = data[col]\n\t\t\tcolor = colors[i % len(colors)]\n\t\t\tfill_color = to_rgba(color, alpha=0.4)\n\t\t\tname = str(col)\n\t\t\tfig.add_trace(go.Violin(\n\t\t\t\tx=vals,\n\t\t\t\tname=name,\n\t\t\t\tbox_visible=show_box,\n\t\t\t\tline_color=color,\n\t\t\t\tfillcolor=fill_color,\n\t\t\t\topacity=0.7,\n\t\t\t\tpoints='all' if show_points else None,\n\t\t\t\tside=violin_side,\n\t\t\t\twidth=0.7,\n\t\t\t\tlegendgroup=name,\n\t\t\t\tscalemode=\"width\",\n\t\t\t\tshowlegend=True,\n\t\t\t\tmeanline_visible=show_box,\n\t\t\t\tspanmode='soft',\n\t\t\t\tpointpos=-0.4\n\t\t\t))\n\n\n\telse:\t\n\t\tfor i, df in enumerate(data.partition_by(group)):\n\t\t\tvals = df[value_cols[0]] # Only first column for grouped\n\t\t\tcolor = colors[i % len(colors)]\n\t\t\tfill_color = to_rgba(color, alpha=0.4)\n\n\t\t\tname = df.get_column(group).first()\n\t\t\tfig.add_trace(go.Violin(\n\t\t\t\tx=vals,\n\t\t\t\tname=name,\n\t\t\t\tbox_visible=show_box,\n\t\t\t\tline_color=color,\n\t\t\t\tfillcolor=fill_color,\n\t\t\t\topacity=0.7,\n\t\t\t\tpoints='all' if show_points else None,\n\t\t\t\tside=violin_side,\n\t\t\t\twidth=0.7,\n\t\t\t\tlegendgroup=name,\n\t\t\t\tscalemode=\"width\",\n\t\t\t\tshowlegend=True,\n\t\t\t\tmeanline_visible=show_box,\n\t\t\t\tspanmode='soft',\n\t\t\t\tpointpos=-0.4\n\t\t\t))\n\n\n\tfig.update_layout(\n\t\ttemplate=template,\n\t\ttitle=title,\n\t\tviolinmode=\"group\",\n\t\theight=height,\n\t\twidth=width,\n\t)\n\treturn fig\n</code></pre>"}]}
